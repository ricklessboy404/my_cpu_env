指令地址为1c010034的指令为02bffdef(00000010101111111111110111101111)，对应到``inst_ram.mif``文件里面是16398行

我们来看看对应关系：

指令地址为1c010034，基地址为1c000000，

mif文件中行数为16398，基地址为1

0x1c010034 - 0x1c000000 = 0x10034 = 65588(Byte) = 16397(Word) 

而16397恰好等于16398 - 1，因此指令RAM里面装的就是从0x1c000000开始的所有指令

而在0x1400001a这条指令处，两个机器出现了分歧，my_cpu选择继续执行，但是标准核一直卡在1c010038这个位置，因此观察这条指令：

0x1400001a = 00010100000000000000000000011010，这是一条LU12I.W指令，看起来是不会卡住的，

那我们接着看下条：00101001100000000000000010001101，这是条ST.W指令，看起来也是不会卡住的，

那这下就很奇怪了，为啥ref的pc一直是0x1c010038但是这里面既没有分支有没有stall，不太明白，但是后面倒是能和mycpu同步上，同步上过了一条指令就出错了，我们来看看：

错误之前的指令为：

0x14000017，地址在0x1c01004c，查到其二进制代码为:00010100000000000000000000010111,又是一条LU12I指令

再下一条是54794000，其二进制为：01010100011110010100000000000000，这是一条BL指令！！！太好了，这个地方就会出现错误了。

![image-20250505154217511](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250505154217511.png)

但是很奇怪，这里的ref只是比原来拖了一拍，一个周期没做完这个事情而已，跳转的位置都是一样的，说明跳转可能没有问题，而是L这个东西写错了。

![image-20250505154458341](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250505154458341.png)

发现这个写寄存器的时候如果bl有效反而是不让写，这是怪事，给他删了看。

改完对了！哈哈哈哈

第二个错代码是这个：00000000010000001110001011101101

这是一条SLLI.W指令，翻译过来是：

SLLI.W 	r13	,	r23	,	$24

意思是将r23里面的数据**逻辑左移**24位，结果放在r13里面

![image-20250505160617370](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250505160617370.png)

这个时候看到r23里面的值是0x00000001，左移24位是0x01000000，这是正确的结果，但是``my_cpu``里面结果是0x00000070，来看看左移的逻辑，应该有点问题的。但是这个不该有问题啊，左移再怎么左移都不会多一堆1出来啊。感觉是移位逻辑根本就是错的。0x00000070展开是：

> 00000000000000000000000001110000 	//展开
>
> 0000000000000000000000000000001	  //没展开

![image-20250505161806786](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250505161806786.png)

检查代码发现这一句，写反了，改了之后就对了



第三处错误代码是0x001569ac，翻译过来是:0000 0000 0001 0101 0110 1001 1010 1100，这是一个OR指令，具体翻译出来如下：

> OR 	r12	，	r13	，	r26

相当于是r12 <= r13 | r26，

查看寄存器堆，此时r26 = 0x1，r13=0x01000000，那么两个做or运算，结果应该是:0x01000001,但是代码``my_cpu``结果是0x05000001，展开为2进制如下：

> 00000001000000000000000000000001	//正确结果
>
> 00000101000000000000000000000001         //错误结果

发现是多了一位1.按理说正常做或运算不太可能出现这种错误，看看源码发现：

![image-20250505163809250](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250505163809250.png)

莫名其妙又或上一个alu_result,并且下面alu_result的生成还依赖or_result，成环了，后面可能导致仿真无法结束，这是个严重错误。

改了之后错误没了。



第四处错误：

错误代码是0x0044898a，翻译为二进制为：0000 0000 0100 0100 1000 1001 1000 1010，这是一条SRLI.W指令，翻译出来就是：

>SRLI.W 	r10	,	r12	,	$2

相当于r10 <= r12 >> 2，注意，此处是逻辑右移，头上补0即可。

r12的值为0x0c00000b，正确写的结果应该是：0x03000002。但是参考答案是：0x23a3ff38，这个和r11的值很像，r11的值是0x23a3ff38，正好是要写的值。看到代码里面srl是这样写的：

![image-20250505171420832](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250505171420832.png)

记录一下错误发生的位置：

![image-20250505170941868](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250505170941868.png)

改了之后完全通过了！！！

![image-20250505171439617](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250505171439617.png)



## 总结

上面写的有点乱，此处总结一下如何利用``golden_trance``来测试自己的CPU：

利用``golden_trance``测试自己的CPU核时如果有错会输出这样的内容：

> [ timestamp ns] Error!!!
>
> ​	reference:    PC  =  0x........， wb_rf_wnum  =  0x........,      wb_rf_wdata  = 0x.........
>
> ​	mycpu      :    PC  =  0x........， wb_rf_wnum  =  0x........,      wb_rf_wdata  = 0x.........

第一行是``golden_trance``对应的输出，第二行是``mycpu``对应的输出。主要看两个有啥不一样的地方。

一行中的参数含义如下：

|    PC    |    wb_rf_wnum    |    wb_rf_wdata     |
| :------: | :--------------: | :----------------: |
| 指令地址 | 要写的寄存器编号 | 要写入寄存器的数据 |

* 一般来说PC都是一样的。如果PC一样，就看看是哪条指令出了问题，指令内容可以在inst_ram_rdata里面看到，根据16进制值查询[2023041918122813624.龙芯架构32位精简版参考手册_r1p03.pdf](https://www.loongson.cn/uploads/images/2023041918122813624.龙芯架构32位精简版参考手册_r1p03.pdf)即可。

* 如果PC不一样，那么可以追踪波形。在20条指令的单周期CPU核中，每条指令都只要一个周期，但是对于``golden_trace``不一定，有可能一个指令会花多个周期，导致标准核和自制核PC产生偏差。这种时候可以去观察错开那一拍的指令。一般是“分支转移"类型指令错误了。例如``bl，bne``等等。

在改正my_cpu的过程中只靠需要写寄存器的指令就能完成debug，但是如果``b，st.w``这种不用写寄存器的指令，出错了也不会报错，就算报错大概率也不会在这些指令的原位置。这种错误的处理还需后面再研究。